# -*- coding: utf-8 -*-
# Slicer -> ROS2 tf2: base_link -> slicer_line_goal
# 观察坐标系：Phantom 为原点
# 链：TrackerToRobot2(= ^Robot T_Tracker), PReferenceToTracker(= ^Tracker T_PReference),
#     PhantomToPReference(= ^PReference T_Phantom)
# 目标：发布 ^Robot T_goal，经局部 Rz(+90) 再 Ry(+90) 的附加旋转
import numpy as np, vtk, slicer

# ===== 配置 =====
LINE_NODE_NAME   = 'LTrajectory9'
DRILLTIP_LABEL   = 'DrillTip'       # 决定朝向的点
TARGET_LABEL     = 'RobotTarget'    # 决定位置的点（平移列）

# 变换节点名（严格遵循 AtoB = ^B T_A）
TNAME_TRK_TO_ROB   = 'TrackerToRobot2'      # ^Robot     T_Tracker
TNAME_PREF_TO_TRK  = 'PReferenceToTracker'  # ^Tracker   T_PReference
TNAME_P_TO_PREF    = 'PhantomToPReference'  # ^PReferenceT_Phantom

WORLD_FRAME      = 'slicer_world'
BASE_FRAME       = 'base_link'
GOAL_FRAME       = 'slicer_line_goal'
TRANS_NODE_NAME  = 'T_base_to_goal'   # 驱动 Broadcaster 的 Transform 节点
HEARTBEAT_MS     = 100

# ===== 小工具 =====
def mul(a,b):
    out = vtk.vtkMatrix4x4()
    vtk.vtkMatrix4x4.Multiply4x4(a,b,out)
    return out

def rotZ_deg(theta_deg):
    th = np.deg2rad(theta_deg); c, s = np.cos(th), np.sin(th)
    m = vtk.vtkMatrix4x4(); m.Identity()
    m.SetElement(0,0,c);  m.SetElement(0,1,-s)
    m.SetElement(1,0,s);  m.SetElement(1,1, c)
    return m

def rotY_deg(theta_deg):
    th = np.deg2rad(theta_deg); c, s = np.cos(th), np.sin(th)
    m = vtk.vtkMatrix4x4(); m.Identity()
    m.SetElement(0,0,c); m.SetElement(0,2,s)
    m.SetElement(2,0,-s); m.SetElement(2,2,c)
    return m

def get_lin_T_to_parent(name):
    node = slicer.util.getNode(name)
    assert node and node.IsA('vtkMRMLTransformNode') and node.IsLinear(), f"{name} 不存在/非线性"
    M = vtk.vtkMatrix4x4()
    ok = node.GetMatrixTransformToParent(M)   # ^Parent T_Node
    if ok == 0: raise RuntimeError(f"读取失败: {name}")
    return M

# ===== Markups（Phantom“局部”坐标，单位 mm）=====
line = slicer.util.getNode(LINE_NODE_NAME)
assert line.IsA('vtkMRMLMarkupsLineNode') and line.GetNumberOfControlPoints() >= 2

def get_point_local(mk, label):
    for i in range(mk.GetNumberOfControlPoints()):
        if mk.GetNthControlPointLabel(i) == label:
            p=[0,0,0]; mk.GetNthControlPointPosition(i,p)  # **Local to parent (应为 Phantom)**
            return np.array(p, dtype=float)
    raise RuntimeError(f"未找到控制点: {label}")

def pose_from_two_points_local(p_pos, p_dir):
    # x 轴 = (dir - pos)；平移 = pos（均在 Phantom 局部）
    x = p_dir - p_pos
    n = np.linalg.norm(x);  assert np.isfinite(n) and n >= 1e-6, "两点过近/非法"
    x = x / n
    up = np.array([0,0,1.0], float)
    if abs(float(np.dot(x, up))) > 0.95: up = np.array([0,1.0,0], float)
    z = np.cross(x, up); z = z/np.linalg.norm(z)
    y = np.cross(z, x)
    M = vtk.vtkMatrix4x4()
    for r in range(3):
        M.SetElement(r,0, float(x[r]))
        M.SetElement(r,1, float(y[r]))
        M.SetElement(r,2, float(z[r]))
        M.SetElement(r,3, float(p_pos[r]))   # RobotTarget in Phantom(mm)
    M.SetElement(3,0,0); M.SetElement(3,1,0); M.SetElement(3,2,0); M.SetElement(3,3,1)
    return M

# ===== 驱动 Transform 节点 =====
Tnode = slicer.mrmlScene.GetFirstNodeByName(TRANS_NODE_NAME)
if not Tnode:
    Tnode = slicer.vtkMRMLLinearTransformNode(); Tnode.SetName(TRANS_NODE_NAME)
    slicer.mrmlScene.AddNode(Tnode)

# 附加旋转：在“现有 TF 基础上”做**局部**Rz(+90)→Ry(+90)，右乘
Rz90 = rotZ_deg(90.0)
Ry90 = rotY_deg(90.0)

def update_base_to_goal_transform():
    # 1) ^Phantom T_goal  （来自 Phantom 局部两点）
    p_pos = get_point_local(line, TARGET_LABEL)   # 位置 = RobotTarget
    p_dir = get_point_local(line, DRILLTIP_LABEL) # 朝向 = DrillTip
    T_P_goal = pose_from_two_points_local(p_pos, p_dir)

    # 2) 读取链：^Robot T_Tracker，^Tracker T_PReference，^PReference T_Phantom
    T_R_Trk  = get_lin_T_to_parent(TNAME_TRK_TO_ROB)
    T_Trk_Pr = get_lin_T_to_parent(TNAME_PREF_TO_TRK)
    T_Pr_P   = get_lin_T_to_parent(TNAME_P_TO_PREF)

    # 3) 组合：^Robot T_goal = ^Robot T_Trk * ^Trk T_Pr * ^Pr T_P * ^P T_goal
    T_R_goal = mul(T_R_Trk, mul(T_Trk_Pr, mul(T_Pr_P, T_P_goal)))

    # 4) 在“现有 TF”上做局部 Rz(+90)→Ry(+90)：T' = T · Rz · Ry
    T_R_goal_adj = mul(T_R_goal, mul(Rz90, Ry90))

    # 5) 写入节点（Slicer 内 RAS/mm；Broadcaster 自动做单位/坐标系转换）
    Tnode.SetMatrixTransformToParent(T_R_goal_adj)

    # 调试（应为非零）
    print("[dbg] ^RobotT_goal_adj t(mm) =",
          [T_R_goal_adj.GetElement(r,3) for r in range(3)])

# ===== ROS2 / tf2 广播（ObserveTransformNode）=====
rosLogic = slicer.util.getModuleLogic('ROS2')
rosNode  = rosLogic.GetDefaultROS2Node()

# world->base：若无需要可保持单位阵一次性广播
bcast_world = rosNode.CreateAndAddTf2BroadcasterNode(WORLD_FRAME, BASE_FRAME)
bcast_world.Broadcast(vtk.vtkMatrix4x4())  # Identity

# base->goal：由 Transform 节点驱动
bcast_goal  = rosNode.CreateAndAddTf2BroadcasterNode(BASE_FRAME, GOAL_FRAME)
bcast_goal.ObserveTransformNode(Tnode)

# 初次与心跳/监听
update_base_to_goal_transform()

import vtk as _vtk, qt
def _on_line_modified(caller, evt):
    try: update_base_to_goal_transform()
    except Exception as e: print("[warn] skipped:", e)

for ev in [getattr(slicer.vtkMRMLMarkupsNode,'PointModifiedEvent',None),
           getattr(slicer.vtkMRMLMarkupsNode,'PointEndInteractionEvent',None),
           _vtk.vtkCommand.ModifiedEvent]:
    if ev is not None: line.AddObserver(ev, _on_line_modified)

_timer = qt.QTimer(); _timer.setInterval(HEARTBEAT_MS)
_timer.connect('timeout()', update_base_to_goal_transform); _timer.start()
