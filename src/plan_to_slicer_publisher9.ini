# -*- coding: utf-8 -*-
# Slicer -> ROS2 tf2: base_link -> slicer_line_goal
# 在现有 TF 基础上附加旋转：先绕Z+90°，再绕Y+90°（右手；局部轴；post-multiply）

import numpy as np, vtk, slicer

# ===== 配置 =====
LINE_NODE_NAME   = 'LTrajectory9'
DRILLTIP_LABEL   = 'DrillTip'       # 朝向点（direction point）
TARGET_LABEL     = 'RobotTarget'    # 位置点（position point）

WORLD_FRAME      = 'slicer_world'
BASE_FRAME       = 'base_link'
GOAL_FRAME       = 'slicer_line_goal'
TRANS_NODE_NAME  = 'T_base_to_goal'      # 驱动 Broadcaster 的 Transform 节点
HEARTBEAT_MS     = 100

# 若 base_link 与 slicer_world 已对齐，保持单位阵；否则填入 ^BaseT_World
M_World_to_Base = vtk.vtkMatrix4x4(); M_World_to_Base.Identity()   # ^Base T_World

# ===== 工具函数 =====
def mul(a,b):
    out = vtk.vtkMatrix4x4()
    vtk.vtkMatrix4x4.Multiply4x4(a,b,out)
    return out

def rotZ_deg(theta_deg):
    th = np.deg2rad(theta_deg)
    c, s = np.cos(th), np.sin(th)
    m = vtk.vtkMatrix4x4()
    m.Identity()
    m.SetElement(0,0, c);  m.SetElement(0,1,-s)
    m.SetElement(1,0, s);  m.SetElement(1,1, c)
    return m

def rotY_deg(theta_deg):
    th = np.deg2rad(theta_deg)
    c, s = np.cos(th), np.sin(th)
    m = vtk.vtkMatrix4x4()
    m.Identity()
    m.SetElement(0,0,  c); m.SetElement(0,2, s)
    m.SetElement(2,0, -s); m.SetElement(2,2, c)
    return m

# ===== Markups（世界坐标，RAS，mm）=====
line = slicer.util.getNode(LINE_NODE_NAME)
assert line.IsA('vtkMRMLMarkupsLineNode') and line.GetNumberOfControlPoints() >= 2

def get_point_world(mk, label):
    for i in range(mk.GetNumberOfControlPoints()):
        if mk.GetNthControlPointLabel(i) == label:
            p=[0,0,0]; mk.GetNthControlPointPositionWorld(i,p)  # ^World, mm
            return np.array(p, dtype=float)
    raise RuntimeError(f"未找到控制点标签: {label}")

def pose_from_two_points_world(p_pos, p_dir):
    # x 轴 = (dir - pos)；平移 = pos
    x = p_dir - p_pos
    n = np.linalg.norm(x)
    if not np.isfinite(n) or n < 1e-6:
        raise RuntimeError("两点过近或非法")
    x = x / n
    up = np.array([0,0,1.0], float)
    if abs(float(np.dot(x, up))) > 0.95:
        up = np.array([0,1.0,0], float)
    z = np.cross(x, up); z = z/np.linalg.norm(z)
    y = np.cross(z, x)
    M = vtk.vtkMatrix4x4()
    for r in range(3):
        M.SetElement(r,0, float(x[r]))
        M.SetElement(r,1, float(y[r]))
        M.SetElement(r,2, float(z[r]))
        M.SetElement(r,3, float(p_pos[r]))   # 平移=RobotTarget，单位mm
    M.SetElement(3,0,0); M.SetElement(3,1,0); M.SetElement(3,2,0); M.SetElement(3,3,1)
    return M

# ===== 驱动 Transform 节点（Slicer 内仍为 RAS/mm）=====
Tnode = slicer.mrmlScene.GetFirstNodeByName(TRANS_NODE_NAME)
if not Tnode:
    Tnode = slicer.vtkMRMLLinearTransformNode(); Tnode.SetName(TRANS_NODE_NAME)
    slicer.mrmlScene.AddNode(Tnode)

# ===== 计算与更新（含附加旋转）=====
# 约定：附加旋转为“局部(intrinsic)”，因此右乘：T' = T · Rz(90) · Ry(90)
Rz90 = rotZ_deg(90.0)
Ry90 = rotY_deg(0.0)

def update_base_to_goal_transform():
    # 1) ^World T_goal（由两点构造；位置=RobotTarget，方向指向=DrillTip）
    p_pos = get_point_world(line, TARGET_LABEL)   # RobotTarget
    p_dir = get_point_world(line, DRILLTIP_LABEL) # DrillTip
    T_W_goal = pose_from_two_points_world(p_pos, p_dir)

    # 2) 换到 base_link：^Base T_goal
    T_B_goal = mul(M_World_to_Base, T_W_goal)

    # 3) 在“现有TF基础上”附加局部旋转：先 Z+90° 再 Y+90°
    T_B_goal_adj = mul(T_B_goal, mul(Rz90, Ry90))

    # 4) 写入 Transform 节点（Broadcaster 观察该节点并自动完成 RAS→ROS、mm→m）
    Tnode.SetMatrixTransformToParent(T_B_goal_adj)

    # 调试输出（应为非零）
    print("[dbg] ^BaseT_goal_adj t(mm) =",
          [T_B_goal_adj.GetElement(r,3) for r in range(3)])

# ===== ROS2 / tf2 广播（ObserveTransformNode）=====
rosLogic = slicer.util.getModuleLogic('ROS2')
rosNode  = rosLogic.GetDefaultROS2Node()

# world->base（如非对齐，可改为你的 ^WorldT_Base 并周期重发）
bcast_world = rosNode.CreateAndAddTf2BroadcasterNode(WORLD_FRAME, BASE_FRAME)
bcast_world.Broadcast(vtk.vtkMatrix4x4())  # Identity

# base->goal（由 Transform 节点驱动）
bcast_goal  = rosNode.CreateAndAddTf2BroadcasterNode(BASE_FRAME, GOAL_FRAME)
bcast_goal.ObserveTransformNode(Tnode)

# 初次与心跳
update_base_to_goal_transform()

import vtk as _vtk, qt
def _on_line_modified(caller, evt):
    try: update_base_to_goal_transform()
    except Exception as e: print("[warn] skipped:", e)

for ev in [getattr(slicer.vtkMRMLMarkupsNode,'PointModifiedEvent',None),
           getattr(slicer.vtkMRMLMarkupsNode,'PointEndInteractionEvent',None),
           _vtk.vtkCommand.ModifiedEvent]:
    if ev is not None: line.AddObserver(ev, _on_line_modified)

_timer = qt.QTimer(); _timer.setInterval(HEARTBEAT_MS)
_timer.connect('timeout()', update_base_to_goal_transform); _timer.start()
